# 자바8 병렬 스트림

컬렉션에 parallelStream을 호출하면 병렬 스트림이 생성된다.
* 각각의 스레드에서 처리할 수 있도록 스트림 요소를 청크로 분할한 스트림
* 모든 멀티코어 프로세서가 각각의 청크를 처리하도록 할당할 수 있다.

순차 스트림에 parallel 메서드를 호출하면 기존의 함수형 리듀싱 연산이 병렬로 처리된다.
* 순차 스트림에 parallel을 호출해도 스트림 자체에는 아무 변화도 일어나지 않는다.
    * parallel을 호출하면 이후 연산이 병렬로 수행해야 함을 의미하는 불린 플래그가 설정된다.

병렬 스트림에서 사용하는 스레드 풀 설정
* 병렬 스트림은 내부적으로 ForkJoinPool을 사용한다.
    * 기본적으로 프로세서 수, 즉 Runtime.getRuntime(), availableProcessors()가 반환하는 값에 상응하는 스레드를 갖는다.
* 일반적으로 기기의 프로세서 수와 같으므로 특별한 이유가 없으면 기본값 그대로 사용할 것을 권장

병렬화는 꽁짜가 아니다.
* 스트림을 재귀적으로 분할
* 각 서브스트림을 서로 다른 스레드의 리듀싱 연산으로 할당
* 이들의 결과를 하나의 값으로 합쳐야 한다.
* 멀티코어 간의 데이터 이동은 생각보다 비싸다.
* 따라서 코어 간에 데이터 전송 시간보다 훨씬 오래 걸리는 작업만 병렬로 다른 코어에서 수행하는 것이 바람직하다.
* 항상 병렬화를 올바르게 사용하고 있는지 확인해야 한다.

병렬 스트림 효과적으로 사용하기
‘천 개 이상의 요소일때 사용하라’와 같이 양을 기준으로 잡는건 적절치 않지만 어떤 상황에서 병렬 스트림을 사용할 것인지 약간의 수량적 힌트를 정하는 것이 도움이 될 때도 있다.
* 확신이 서지 않으면 적절한 벤치마크로 직접 측정하라
* 되도록이면 기본형 특화 스트림(IntStream, LongStream …)을 사용해 박싱을 주의하라
* 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다.
    * Limit, findFirst
    * findAny는 요소의 순서와 상관없이 연산하므로 findFirst보다 성능이 좋다.
    * 정렬된 스트림에 unordered를 호출하면 비정렬된 스트림을 얻을 수 있다.
    * 스트림에 N개 요소가 있을 때 요소 순서가 상관없다면 비정렬된 스트림에 limit를 호출하는게 효율적이다.
* 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라
    * 요소 수가 N, 하나의 요소를 처리하는데 드는 비용이 Q일때 전체 비용은 N*Q이다. Q가 높아진다는 것은 병렬 스트림으로 성능을 개선할 수 있는 가능성
* 소량의 데이터에서는 병렬 스트림이 도움 되지 않는다.
* 스트림을 구성하는 자료구조가 적절한지 확인하라.
    * ArrayList를 LinkedList보다 효율적으로 분할할 수 있다.
* 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성으르 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다.
* 최종 연산의 병합 과정(Collector의 combiner 메서드)의 비용이 비싸면 병렬 스트림으로 얻은 이익이 상쇄된다.

참고
* 자바 8 인 액션